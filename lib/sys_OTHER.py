# -*- coding: utf-8 -*-
import random
import os
import time

###############################################################
# CONSTANT DECLARATIONS                                       #
###############################################################
SLURMCTLD_FILE = '/share/slurm_files/slurmctld.log'

#FCF Done
def get_bsub_arg(params, L):
    params = params.split("/")
    bsub_suffix = list()
    nproc  = int(params[0])
    if nproc:
        bsub_suffix.append("--cores-per-socket="+str(nproc))
    if params[1] != "NA": # memory (Gb)
        mem = str(int(params[1]) * 1024)
        #bsub_suffix.append("-R rusage[mem="+mem+"]")
        bsub_suffix.append("--mem="+mem)
    if params[2] != "NA":
        nchild = int(params[2])
        #bsub_suffix.append("-R span[hosts=1]")
        bsub_suffix.append(" --tasks-per-node=1 ")
    else:
        nchild = nproc
        nproc  = 1
    bsub_suffix = " ".join(bsub_suffix)
    if nchild > L:
        nchild = L
    #return nproc, nchild, bsub_suffix
    return bsub_suffix


def job_status(path):
## RETURNS THE JOB STATUS GIVEN THE PATH TO THE LOG FILE THAT WILL BE GENERATED BY THE RESOURCE MANAGER
## Input:
##   path: Path to the log file that will be generated by the resource manager. In LSF-based systems this log file is specified using the 'bsub' argument '-o'
## Returns:
##   1:  The job has ended successfully based on the log file generated by the resource manager
##   0:  The job is currently running (log file has not been created)
##   -1: The job exited with error based on the log file generated by the resource manager
    status = ""
    f = open(SLURMCTLD_FILE, 'r')
    for i in f:
        i = i.strip("\n")
        if i.endswith(path + " WEXITSTATUS 1"):
            status = "error"
            break
        if i.endswith(path + " WEXITSTATUS 0"):
            status = "ok"
            break
    f.close()
    if status == "ok":
        print "job_status returning 1"
        return 1
    elif status == "error":
        return -1
    else:
        return 0

#FCF: Done
def job_kill(job_id):
## KILLS A JOB GIVEN ITS JOB ID
## Input:
##   job_id: Job ID of the job that will be killed
## Returns:
##   Nothing
    os.system("scancel " + job_id + " &>/dev/null")


# FCF done!
# RETURNS DE PID OF A JOB ACCORDING TO THE OUTPUT OF BSUB SAVED INTO A FILE (PATH)
def get_pid(path, secs):
    time.sleep(secs)
    try:
        f   = open(path, 'r')
        job_id = f.readline().split(" ")
        f.close()
        #os.system("rm " + path)
        return job_id[-1].strip()
    except:
        # error opening or parsing the job submission ouptut file
        return "NA"


#FCF: Done, execpt opts needs to be written
def submit_job(wt, n, slurm_partition, output_log, job_name, path2script, script, pt, bsub_suffix):
    ########################################################################
    ## Submits a job script to cluster
    ########################################################################
    ## wt:  cluster walltime
    ## n:   Number of procs  -R rusage[mem=32768]
    ## slurm_partition:   Slurm partition
    ## output_log:  Path to output log
    ## job_name: Name of job 
    # path2script: Path to script file
    # script: If 1 script, if 0 command
    r = str(random.randint(0, 10000))
    opts = ""
    if script == 0:
        command = 'sbatch -t ' + wt + ' -n ' + n + ' -p ' + slurm_partition + ' -o ' + output_log + ' --job-name=' + job_name + ' --wrap="' + path2script +'"'
    else:
        command = 'sbatch -t ' + wt + ' -n ' + n + ' -p ' + slurm_partition + ' -o ' + output_log + ' --job-name=' + job_name + ' ' + path2script 
    outFile = pt + '/temp/' + job_name + '_' + r + '.txt'
    os.system(command + " > " + outFile)
    job_id = get_pid(outFile, 3)
    return job_id 
